# 개발자 인터뷰 질문 모음

개인적으로 인터뷰를 위해 깔끔한 답변을 정리합니다.

### 1. 클로저란?
클로저는 두개의 함수로 이루어진 특별한 환경이다. 자바스크립트에서는 없는 공개 속성/메소드, 비공개 속성/메소드를 구현할 수 있다.

### 2. This란?
예약어이자 자기참조변수입니다. 객체가 생성될 때, arguments와 같은 유사배열 객체와 함께 암묵적으로 전달된다. 강타입 언어와 달리 자바스크립트에서는 this가 가리키는 값을 4가지 경우로 나누어서 정의할 수 있다.
- 객체의 메소드일 경우
- 함수일 경우
- 객체의 생성자일 경우
- call, bind, apply

### 3. 리렌더링이 발생하는 경우
- 상태가 변경될 때
- 인자(Props)가 변경될 때
- 부모가 리렌더링 될 때

### 4. Virtual DOM이란?
Virtual DOM은 리액트의 렌더링 방식이다. 실제 DOM과 마찬가지로 브라우저 메모리에 가상의 DOM을 생성한다. 리렌더링이 발생하면 갱신된 새로운 Virtual DOM을 생성한다. 이전의 Virtual DOM과 새로운 Virtual DOM의 차이를 비교해서 변경된 노드만 실제 DOM에 반영하고 paint한다.

### 5. 브라우저 동작 순서
- 검색엔진이 해당 입력값이 Search Query인지 단순 URI인지 검사한다.
- URI로 확인되면 브라우저 캐시에 가서 DNS Records를 확인한다.
- 캐시에 존재하지 않는다면 인터넷망 공급자의 DNS에 IP 주소를 요청한다.
- IP 주소를 받아오면 브라우저는 해당 IP 주소에 TCP 연결을 시도하고 index를 위한 자원을 요청한다.
- 서버는 해당 요청 자원에 대한 일련의 작업을 수행하고 브라우저로 전달한다.
- 브라우저는 자원을 받아와 HTML은 DOM Tree로 파싱하고 CSS는 CSSOM으로 파싱한다.
- 두 트리를 활용해 Render Tree를 구성하고 각 노드의 스타일 값을 계산하고(Reflow, Render), 뷰포트에 출력(Paint)한다.

### 6. React.Memo란?
React.Memo는 리액트의 리렌더링에 들어가는 비용을 줄이기 위해 사용된다. 기본적인 사용법은 컴포넌트를 분리하고 Export하는 컴포넌트를 React.Memo로 감싸준다. 이 때 감싸진 컴포넌트는 리렌더링이 부모단에서 발생되어 렌더링될 때, props가 변경되지 않으면 리렌더링되지 않는다.

### 7. useMemo란?
useMemo란 리액트의 기본 훅으로 기존에 수행한 연산의 결괏값을 기억하고 의존값을 설정함으로써 의존값이 변경되지 않으면 값을 재활용한다. 렌더링이 발생하면 해당 하위 컴포넌트의 모든 변수와 메소드가 재선언되기 때문에 연산 또한 다시 해야한다. 이때 useMemo를 활용해서 연산을 기억하고 의존값만 변경되면 재연산을 하도록 하면 컴퓨터 자원을 아낄 수 있다.

### 8. useCallback이란?
useCallback이란 useMemo와 달리 특정 함수를 재사용한다. useCallback으로 정의한 함수는 의존값을 설정하고 의존값이 변경되지 않으면 재선언하지 않는다. 앞서 리렌더링이 발생하면 함수 또한 재선언하는데 이때 함수의 메모리 주소값이 변경된다. 이것은 React가 변경된 값으로 인식하고 리렌더링을 수행한다. useCallback을 사용하면 앞서 재선언 없이 재활용 할 수 있다.

### 9. 실행컨텍스트란?
컨텍스트는 번역하면 맥락으로서 코드의 실행 환경을 의미한다. 전역 컨텍스트와 함수 컨텍스트로 구분 할 수 있으며 실행 컨테스트는 대부분 함수 컨텍스트를 의미한다. 함수가 실행될 때 컨텍스트를 형성하는데 이때 해당 블록 스코프의 Arguments, Variable, Scope Chain, this 등이 포함된다.

### 10. 이벤트 루프란?
자바스크립트는 싱글 쓰레드 방식으로로 동작하고 이벤트루프로 비동기처리를 한다. 이벤트루프는 자바스크릡트 엔진과 태스크큐를 연결하는 역할을 한다.

### 11 이벤트 버블링, 이벤트 캡쳐링
이벤트 버블링은 하위 노드에서 발생한 이벤트가 상위 노드로 전파되는 것을 말한다. 이벤트 캡쳐링은 발생한 이벤트를 찾기 위해 최상위 노드에서 하위 노드로 내려가는 것을 말한다.

### 12. Promise란?
프로미스는 ES6부터 기본 스펙으로 인정받았다. 자바스크립트는 콜백 함수를 통해서 해당 비동기 처리의 일련의 작업을 실행하게되는데 프로젝트의 규모가 방대해지면서 비동기 처리의 복잡성도 높아지게 되었다. 그렇기 때문에 콜백 함수 또한 중첩되면서 콜백 지옥이 발생했다. Promise는 비동기 처리를 좀 더 가시적으로 처리 할 수 있게 해준다. resolve와 reject 메소드를 활용해서 결과 처리를 직관적으로 할 수 있고 비동기 처리를 순차적으로 진행하거나 병렬처리가 가능하게 해준다.

### 13. Async & Await 예외처리 까다로운점은?
Promise 객체 내부에서는 resolve와 reject를 암묵적으로 넘기기 때문에 오류가 발생했을 때는 reject로 처리하면 된다. 하지만 async/await 같은 경우는 Promise 객체를 반환 받고 반환값을 활용해 throw로 오류를 처리해줘야 한다.

### 14. 자바스크립트 원시값이란?
메소드가 없고 객체가 아닌 데이터이다. string, number, undefined, null 등이 있다.

### 15. 가비지콜렉션 알고리즘이란?
객체가 생성되었을 때 자동으로 메모리를 할당하고 더 이상 필요하지 않을 때 자동으로 해체하는 것은 가비지 콜렉션이라고 한다. 주요한 알고리즘으로는 Reference-counting 알고리즘, Mark-and-sweep 알고리즘이 있다.

### 16. Repainting , Reflow란?
Repainting 같은 경우는 style을 계산하고 노드의 스크린에서의 크기와 위치값을 기반으로 뷰포트에 다시 출력한다는 의미입니다. Reflow는 화면 구조가 변경되었을 때 노드들의 위치와 크기를 다시 계산하는 것입니다.

### 17. Display:none; 어떻게 처리, 어느정도 새로그리나?
Display:none;는 렌더 트리에 포함되지 않는다. 아예 노드에서 제외시키기 때문에 해당 노드에 대한 스타일 계산 및 노드의 크기, 위치 계산이 발생하지 않는다.
